# MemoMate(챗노트) - NotebookLM 팟캐스트 스크립트

> 두 명의 호스트(A: 개발자, B: 진행자)가 대화하는 형식

---

## Part 1: 인트로 & 문제 정의 (2분)

**B:** 안녕하세요! 오늘은 정말 흥미로운 프로젝트를 소개해드릴 건데요. 카카오톡 챗봇으로 메모를 관리하는 서비스, "챗노트"입니다. 개발자분 직접 나오셨는데요, 이 서비스 왜 만드시게 됐어요?

**A:** 네, 다들 이런 경험 있으시잖아요. 친구가 카톡으로 맛집 링크 보내줬는데, "나중에 가봐야지" 하고 넘겼다가... 정작 필요할 때 못 찾는 거죠.

**B:** 아, 진짜요! 저도 유튜브 영상 엄청 많이 받는데, 다 어디 갔는지...

**A:** 맞아요. 그리고 메모앱에 따로 저장하자니, 카톡 나가서 앱 열고, 복사 붙여넣기 하고... 이 과정이 너무 귀찮은 거예요.

**B:** 그래서 카톡 안에서 바로 해결하자?

**A:** 정확합니다. **카톡에서 링크 받으면, 그냥 챗봇한테 전달만 하면 끝.** AI가 알아서 "아, 이건 맛집이네", "이건 유튜브 영상이네" 분류해주고, 나중에 "맛집 정리해줘" 하면 쭉 보여주는 거죠.

---

## Part 2: 솔루션 개요 & 사용 시나리오 (3분)

**B:** 오, 그러면 실제로 어떻게 쓰는 건지 시나리오로 보여주실 수 있어요?

**A:** 네, 예를 들어볼게요.

> **시나리오 1: 링크 저장**
>
> 사용자: `https://youtube.com/watch?v=abc123`
>
> 챗봇: "영상 저장 완료! [썸네일 카드]"

**A:** 이게 끝이에요. URL만 보내면 자동으로 유튜브인 걸 인식하고, 제목이랑 썸네일까지 가져와서 예쁘게 카드로 보여줘요.

**B:** 오... 메타데이터를 자동으로 가져오는 거네요?

**A:** 네, 그리고 텍스트 메모도 되거든요.

> **시나리오 2: 텍스트 메모**
>
> 사용자: "강남역 근처 파스타 맛집 발견"
>
> 챗봇: "맛집 저장 완료!"

**A:** "파스타", "맛집" 이런 키워드를 보고 AI가 자동으로 맛집 카테고리로 분류해요.

**B:** 그러면 나중에 찾을 때는요?

**A:** 여러 가지 방법이 있어요.

> **시나리오 3: 조회**
>
> "오늘 정리" → 오늘 저장한 메모 전체
> "이번주 맛집" → 이번주 맛집 카테고리만
> "유튜브 검색" → 유튜브 관련 메모 검색

**B:** 자연어로 말하면 알아듣는 거네요?

**A:** 맞아요. 그리고 재밌는 게, **"오늘 요약"** 하면 AI가 분석해서 "오늘 5건 저장, 영상 3개, 맛집 2개, 영상 관련이 60%네요" 이렇게 인사이트도 줘요.

---

## Part 3: 기술 아키텍처 (4분)

**B:** 기술적으로 어떻게 구현하신 거예요? 서버는 뭘 쓰셨어요?

**A:** 전체 아키텍처를 설명드리면요...

```
[카카오톡 사용자]
       ↓
[카카오 i 오픈빌더] ← 스킬 서버 연동
       ↓
[Vercel 서버리스] ← Python FastAPI
       ↓
[Upstash Redis] ← 서버리스 DB
```

**A:** 핵심은 **"서버리스"**예요. Vercel이랑 Upstash 둘 다 서버리스라서, 사용한 만큼만 비용 내면 돼요.

**B:** 서버리스가 뭔지 쉽게 설명해주시면...

**A:** 일반적으로 서버를 운영하려면 24시간 컴퓨터를 켜놔야 하잖아요. 근데 서버리스는 **요청이 들어올 때만 실행**되고, 안 쓰면 꺼져 있어요. 그래서 비용이 거의 안 들어요.

**B:** 아, 그래서 개인 프로젝트에 적합하군요.

**A:** 네, 그리고 **Upstash Redis**가 진짜 좋은 게, 일반 Redis는 서버에 설치해야 하는데, Upstash는 REST API로 호출해요. 서버리스 환경이랑 찰떡이죠.

**B:** 데이터는 어떤 구조로 저장돼요?

**A:** Redis에 JSON으로 저장하는데요, 핵심 구조가 이래요:

```python
memo = {
    "id": "uuid",
    "content": "원본 텍스트",
    "category": "맛집",        # AI 분류 결과
    "summary": "강남 파스타집", # 요약
    "url": "https://...",      # URL이면
    "metadata": {              # 메타데이터
        "title": "...",
        "thumbnail": "...",
        "site_name": "YouTube"
    },
    "created_at": "2025-01-07T..."
}
```

**B:** 카테고리는 몇 개나 있어요?

**A:** **11개**요. 영상, 음악, 맛집, 쇼핑, 여행, 학습, 할일, 아이디어, 링크, 건강, 기타.

---

## Part 4: AI 핵심 로직 - 하이브리드 분류 (4분)

**B:** 제가 제일 궁금한 게, AI가 어떻게 사용자 의도를 파악하는 거예요? "오늘 정리"랑 "오늘 삭제"는 완전 다른 건데...

**A:** 이게 이 프로젝트의 **핵심 기술**인데요, 저는 **"하이브리드 접근법"**을 썼어요.

**B:** 하이브리드요?

**A:** 네, 두 가지를 섞은 거예요:

1. **규칙 기반 (Rule-based)** - 빠름, 비용 0원
2. **AI 기반 (OpenAI API)** - 정확함, 비용 발생

**A:** 먼저 규칙으로 시도하고, 실패하면 AI한테 물어보는 거죠.

**B:** 규칙 기반이 어떻게 동작해요?

**A:** 코드로 보여드릴게요:

```python
EXACT_MATCHES = {
    # 정확히 일치하는 것들
    "홈": {"intent": "home"},
    "통계": {"intent": "stats"},
    "도움말": {"intent": "help"},

    # 패턴 매칭
    "오늘 정리": {"intent": "summary", "period": "today"},
    "이번주 삭제": {"intent": "delete", "keyword": "이번주"},
    "맛집 정리": {"intent": "summary", "category": "맛집"},
}
```

**A:** 사용자가 "오늘 정리"라고 정확히 입력하면, **0ms**만에 바로 매칭돼요. OpenAI API 호출 없이요.

**B:** 오, 그러면 비용도 안 들고 빠르겠네요!

**A:** 맞아요. 실제로 **80% 이상의 요청이 규칙으로 처리**돼요. 사용자들이 QuickReply 버튼을 누르면 정해진 텍스트가 전송되거든요.

**B:** 그러면 AI는 언제 쓰여요?

**A:** 규칙에 없는 **자유로운 표현**일 때요. 예를 들어:

- "저번주에 저장한 거 보여줘" → AI가 "summary, period=last_week"로 해석
- "유튜브 관련된 것만" → AI가 "summary, category=영상"으로 해석

**A:** 이렇게 하면 **빠르면서도 유연한** 시스템이 되는 거죠.

---

**B:** 카테고리 분류는요? URL이면 어떻게 알아요?

**A:** URL 분류는 더 재밌어요. **도메인 기반 매핑**을 해놨거든요:

```python
PLATFORM_DOMAINS = {
    "youtube": ["youtube.com", "youtu.be"],
    "instagram": ["instagram.com"],
    "spotify": ["spotify.com", "open.spotify.com"],
    "coupang": ["coupang.com"],
    "musinsa": ["musinsa.com"],
    # ... 50개 이상의 플랫폼
}

PLATFORM_TO_CATEGORY = {
    "youtube": "영상",
    "instagram": "영상",
    "spotify": "음악",
    "coupang": "쇼핑",
    "musinsa": "쇼핑",
}
```

**A:** 유튜브 링크가 오면 도메인 보고 바로 "영상"으로 분류해요. AI 호출 없이요.

**B:** 그러면 메타데이터는요? 제목이랑 썸네일 어떻게 가져와요?

**A:** 여기서 **oEmbed API**를 씁니다. 직접 웹페이지 크롤링하면 봇 차단당하거든요. 특히 서버리스 환경에서는요.

```python
# open.iframe.ly - 1600개 이상 도메인 지원
oembed_url = f"https://open.iframe.ly/api/oembed?url={url}"
```

**A:** 이 API가 대신 메타데이터를 가져와줘요. 유튜브, 인스타, 트위터 다 돼요.

**B:** 만약 그것도 실패하면요?

**A:** 3단계 폴백이 있어요:

1. **oEmbed API** 시도
2. 실패 시 → **직접 OG 태그 파싱**
3. 그것도 실패 시 → **기본 썸네일/favicon** 사용

**A:** 유튜브는 특수 처리해서, 비디오 ID만 추출하면 썸네일 URL을 직접 만들 수 있어요:

```python
thumbnail = f"https://i.ytimg.com/vi/{video_id}/hqdefault.jpg"
```

---

## Part 5: 개인화 & 마무리 (2분)

**B:** 개인화 기능도 있다고 하셨는데요?

**A:** 네, **QuickReply 버튼이 사용자마다 달라요**.

**A:** 예를 들어 영상을 많이 저장하는 사용자한테는 "영상 정리" 버튼이 뜨고, 맛집을 많이 저장하는 사람한테는 "맛집 정리" 버튼이 떠요.

```python
async def get_personalized_quick_replies(user_id):
    # 사용자 통계에서 상위 2개 카테고리 조회
    top_cats = await get_user_top_categories(user_id, limit=2)

    # 동적 버튼 생성
    return [
        {"label": "오늘", ...},
        {"label": top_cats[0], ...},  # 사용자 맞춤
        {"label": top_cats[1], ...},  # 사용자 맞춤
        {"label": "삭제", ...},
    ]
```

**B:** 오, 쓰면 쓸수록 나한테 맞춰지는 거네요.

**A:** 맞아요. 그리고 **PlayMCP**랑도 연동돼서, 다른 AI 서비스에서도 이 메모 데이터를 활용할 수 있어요.

---

**B:** 마지막으로 앞으로 계획이 있으시면요?

**A:** 몇 가지 있는데요:
1. **리마인더 알림** - 지금은 저장만 되는데, 실제로 카톡 푸시 보내기
2. **음성 메모** - 카카오 음성 인식 연동
3. **공유 기능** - 친구랑 메모 공유

**B:** 기대되네요! 오늘 정말 유익했습니다. 감사합니다!

**A:** 감사합니다!

---

## 핵심 요약 (발표용)

| 구분 | 기술 | 이유 |
|------|------|------|
| 서버 | Vercel (Python) | 서버리스, 무료 티어 |
| DB | Upstash Redis | 서버리스, REST API |
| 의도 분류 | 규칙 + OpenAI | 빠름 + 정확함 |
| 카테고리 | 도메인 매핑 + AI | URL은 즉시, 텍스트는 AI |
| 메타데이터 | oEmbed API | 봇 차단 우회 |
| 챗봇 | 카카오 i 오픈빌더 | 국내 사용자 접근성 |

---

*이 스크립트는 NotebookLM 스타일 팟캐스트 형식으로 작성되었습니다.*
