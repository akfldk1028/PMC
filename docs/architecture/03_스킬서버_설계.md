# 스킬서버 설계

## 1. 개요

스킬서버는 카카오 챗봇으로부터 사용자 메시지를 받아 처리하는 핵심 서버입니다.

```
카카오 챗봇 → POST /skill → 스킬서버 → 처리 → 응답
```

---

## 2. 주요 기능

| 기능 | 설명 |
|------|------|
| 메시지 수신 | 카카오 챗봇에서 전달된 메시지 파싱 |
| 타입 분석 | URL vs 텍스트 구분 |
| 메타데이터 추출 | URL인 경우 OG 태그, 제목 등 추출 |
| AI 분류 | Kanana API로 카테고리/태그/요약 생성 |
| DB 저장 | 정리된 메모 저장 |
| 알림 전송 | 나에게 보내기 API로 정리본 전송 |
| 응답 반환 | 챗봇에 결과 응답 |

---

## 3. 처리 플로우

```
[메시지 수신]
     │
     ▼
[타입 분석] ─── URL인가? ───┬─── Yes ──→ [메타데이터 추출]
                           │                    │
                           No                   │
                           │                    ▼
                           ▼              [OG 태그, 제목]
                    [텍스트 메모]                │
                           │                    │
                           └────────┬───────────┘
                                    ▼
                           [Kanana API 호출]
                           - 카테고리 분류
                           - 태그 생성
                           - 요약 생성
                                    │
                                    ▼
                            [DB에 저장]
                                    │
                                    ▼
                     [나에게 보내기 API 호출]
                                    │
                                    ▼
                        [챗봇 응답 반환]
```

---

## 4. 코드 구현

### 4.1 메인 엔드포인트

```python
# api/skill.py
from fastapi import FastAPI, Request, BackgroundTasks
from fastapi.responses import JSONResponse
import re
from lib.kanana import analyze_memo
from lib.kakao import send_to_me
from lib.db import save_memo

app = FastAPI()

# URL 패턴
URL_PATTERN = re.compile(r'https?://[^\s]+')

@app.post("/skill")
async def skill_handler(request: Request, background_tasks: BackgroundTasks):
    body = await request.json()

    # 사용자 정보 추출
    user_id = body["userRequest"]["user"]["id"]
    utterance = body["userRequest"]["utterance"]

    # 특수 명령어 처리
    if "정리" in utterance or "요약" in utterance:
        return await handle_summary(user_id, utterance)
    elif "검색" in utterance:
        return await handle_search(user_id, utterance)

    # 일반 메모 저장
    # 1. 즉시 응답 (5초 제한 대응)
    quick_response = create_response("📌 메모 저장 중...")

    # 2. 백그라운드에서 처리
    background_tasks.add_task(process_memo, user_id, utterance)

    return JSONResponse(quick_response)


async def process_memo(user_id: str, utterance: str):
    """백그라운드에서 메모 처리"""
    try:
        # URL 추출
        urls = URL_PATTERN.findall(utterance)
        memo_type = "url" if urls else "text"

        # 메타데이터 추출 (URL인 경우)
        metadata = {}
        if urls:
            metadata = await extract_metadata(urls[0])

        # Kanana API로 분류
        analysis = await analyze_memo(utterance, metadata)

        # DB에 저장
        memo_id = await save_memo(
            user_id=user_id,
            content=utterance,
            memo_type=memo_type,
            category=analysis["category"],
            tags=analysis["tags"],
            summary=analysis["summary"],
            metadata=metadata
        )

        # 나에게 보내기
        message = format_memo_message(analysis)
        await send_to_me(user_id, message)

    except Exception as e:
        print(f"Error processing memo: {e}")
```

### 4.2 URL 메타데이터 추출

```python
# lib/metadata.py
import httpx
from bs4 import BeautifulSoup

async def extract_metadata(url: str) -> dict:
    """URL에서 OG 태그, 제목 등 추출"""
    try:
        async with httpx.AsyncClient() as client:
            response = await client.get(url, timeout=5.0)
            soup = BeautifulSoup(response.text, 'html.parser')

            # OG 태그 추출
            og_title = soup.find("meta", property="og:title")
            og_description = soup.find("meta", property="og:description")
            og_image = soup.find("meta", property="og:image")

            # 일반 title
            title = soup.find("title")

            return {
                "title": og_title["content"] if og_title else (title.text if title else ""),
                "description": og_description["content"] if og_description else "",
                "image": og_image["content"] if og_image else "",
                "url": url,
                "type": detect_url_type(url)
            }
    except:
        return {"url": url, "type": detect_url_type(url)}


def detect_url_type(url: str) -> str:
    """URL 타입 감지"""
    if "youtube.com" in url or "youtu.be" in url:
        return "youtube"
    elif "instagram.com" in url:
        return "instagram"
    elif "naver.com" in url:
        return "naver"
    elif "tistory.com" in url or "velog.io" in url:
        return "blog"
    else:
        return "link"
```

### 4.3 Kanana API 연동

```python
# lib/kanana.py
import httpx
import os
import json

KANANA_API_URL = "https://api.kakao.com/v1/kanana/chat"
KANANA_API_KEY = os.environ.get("KANANA_API_KEY")

async def analyze_memo(content: str, metadata: dict = None) -> dict:
    """Kanana API로 메모 분석"""

    # 프롬프트 구성
    prompt = f"""다음 메모를 분석해서 JSON으로 반환해줘.

메모: {content}
{f"메타데이터: {json.dumps(metadata, ensure_ascii=False)}" if metadata else ""}

응답 형식:
{{
    "category": "영상/맛집/쇼핑/할일/아이디어/읽을거리/기타 중 하나",
    "tags": ["태그1", "태그2", "태그3"],
    "summary": "한줄 요약 (30자 이내)"
}}
"""

    async with httpx.AsyncClient() as client:
        response = await client.post(
            KANANA_API_URL,
            headers={
                "Authorization": f"Bearer {KANANA_API_KEY}",
                "Content-Type": "application/json"
            },
            json={
                "model": "kanana-2-30b",
                "messages": [{"role": "user", "content": prompt}]
            }
        )

        result = response.json()
        # 응답 파싱
        answer = result["choices"][0]["message"]["content"]
        return json.loads(answer)
```

### 4.4 나에게 보내기 API

```python
# lib/kakao.py
import httpx
import os

KAKAO_API_URL = "https://kapi.kakao.com/v2/api/talk/memo/default/send"

async def send_to_me(user_access_token: str, message: str):
    """카카오톡 나에게 보내기"""

    template = {
        "object_type": "text",
        "text": message,
        "link": {
            "web_url": "https://playmcp.kakao.com",
            "mobile_web_url": "https://playmcp.kakao.com"
        }
    }

    async with httpx.AsyncClient() as client:
        response = await client.post(
            KAKAO_API_URL,
            headers={
                "Authorization": f"Bearer {user_access_token}",
                "Content-Type": "application/x-www-form-urlencoded"
            },
            data={"template_object": json.dumps(template)}
        )

        return response.json()
```

### 4.5 응답 생성 헬퍼

```python
# lib/response.py

def create_response(text: str) -> dict:
    """카카오 챗봇 응답 생성"""
    return {
        "version": "2.0",
        "template": {
            "outputs": [
                {
                    "simpleText": {
                        "text": text
                    }
                }
            ]
        }
    }


def format_memo_message(analysis: dict) -> str:
    """정리된 메모 메시지 포맷"""
    category_emoji = {
        "영상": "📺",
        "맛집": "🍽️",
        "쇼핑": "🛒",
        "할일": "📅",
        "아이디어": "💡",
        "읽을거리": "📰",
        "기타": "📌"
    }

    emoji = category_emoji.get(analysis["category"], "📌")
    tags = " ".join([f"#{tag}" for tag in analysis["tags"]])

    return f"""
{emoji} 메모 저장 완료!

📂 카테고리: {analysis["category"]}
🏷️ 태그: {tags}
📝 요약: {analysis["summary"]}
""".strip()
```

---

## 5. 특수 명령어 처리

### 5.1 정리/요약 명령

```python
async def handle_summary(user_id: str, utterance: str):
    """정리 요청 처리"""
    from lib.db import get_memos_by_period

    # 기간 파악
    if "오늘" in utterance:
        period = "today"
    elif "이번주" in utterance:
        period = "week"
    elif "이번달" in utterance:
        period = "month"
    else:
        period = "today"

    memos = await get_memos_by_period(user_id, period)

    if not memos:
        return JSONResponse(create_response("저장된 메모가 없습니다."))

    # 카테고리별 정리
    summary = format_summary(memos, period)

    return JSONResponse(create_response(summary))
```

### 5.2 검색 명령

```python
async def handle_search(user_id: str, utterance: str):
    """검색 요청 처리"""
    from lib.db import search_memos

    # 검색어 추출
    keyword = utterance.replace("검색", "").strip()

    memos = await search_memos(user_id, keyword)

    if not memos:
        return JSONResponse(create_response(f"'{keyword}' 관련 메모가 없습니다."))

    result = format_search_result(memos, keyword)

    return JSONResponse(create_response(result))
```

---

## 6. Vercel 배포 설정

### vercel.json

```json
{
  "version": 2,
  "builds": [
    {
      "src": "api/skill.py",
      "use": "@vercel/python"
    }
  ],
  "routes": [
    {
      "src": "/skill",
      "dest": "/api/skill.py"
    }
  ]
}
```

### requirements.txt

```
fastapi>=0.100.0
httpx>=0.24.0
beautifulsoup4>=4.12.0
```

---

## 7. 환경 변수

| 변수 | 설명 |
|------|------|
| `KANANA_API_KEY` | Kanana API 키 |
| `KAKAO_CLIENT_ID` | 카카오 앱 REST API 키 |
| `DATABASE_URL` | DB 연결 문자열 |

---

## 8. 다음 문서

- [04_MCP_서버_설계.md](./04_MCP_서버_설계.md) - PlayMCP MCP 서버
- [05_데이터_모델.md](./05_데이터_모델.md) - DB 스키마
