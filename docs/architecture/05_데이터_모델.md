# ë°ì´í„° ëª¨ë¸ ì„¤ê³„

## 1. ê°œìš”

ì±—ë…¸íŠ¸ì˜ ë°ì´í„°ë² ì´ìŠ¤ ìŠ¤í‚¤ë§ˆì…ë‹ˆë‹¤.

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚     users       â”‚       â”‚     memos       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤       â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ id (PK)         â”‚â”€â”€â”    â”‚ id (PK)         â”‚
â”‚ kakao_id        â”‚  â”‚    â”‚ user_id (FK)    â”‚â†â”€â”˜
â”‚ access_token    â”‚  â”‚    â”‚ content         â”‚
â”‚ created_at      â”‚  â”‚    â”‚ memo_type       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚    â”‚ category        â”‚
                     â”‚    â”‚ tags            â”‚
                     â”‚    â”‚ summary         â”‚
                     â”‚    â”‚ url             â”‚
                     â”‚    â”‚ metadata        â”‚
                     â”‚    â”‚ created_at      â”‚
                     â”‚    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## 2. í…Œì´ë¸” ì •ì˜

### 2.1 users í…Œì´ë¸”

ì‚¬ìš©ì ì •ë³´ ì €ì¥

```sql
CREATE TABLE users (
    id TEXT PRIMARY KEY,           -- ë‚´ë¶€ ì‚¬ìš©ì ID (UUID)
    kakao_id TEXT UNIQUE NOT NULL, -- ì¹´ì¹´ì˜¤ ì‚¬ìš©ì ID
    access_token TEXT,             -- ì¹´ì¹´ì˜¤ ì•¡ì„¸ìŠ¤ í† í° (ë‚˜ì—ê²Œ ë³´ë‚´ê¸°ìš©)
    refresh_token TEXT,            -- ë¦¬í”„ë ˆì‹œ í† í°
    token_expires_at TIMESTAMP,    -- í† í° ë§Œë£Œ ì‹œê°„
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- ì¸ë±ìŠ¤
CREATE INDEX idx_users_kakao_id ON users(kakao_id);
```

| ì»¬ëŸ¼ | íƒ€ì… | ì„¤ëª… |
|------|------|------|
| id | TEXT | ë‚´ë¶€ UUID |
| kakao_id | TEXT | ì¹´ì¹´ì˜¤ ì œê³µ ì‚¬ìš©ì ID |
| access_token | TEXT | OAuth ì•¡ì„¸ìŠ¤ í† í° |
| refresh_token | TEXT | í† í° ê°±ì‹ ìš© |
| token_expires_at | TIMESTAMP | í† í° ë§Œë£Œ ì‹œê°„ |
| created_at | TIMESTAMP | ê°€ì… ì‹œê°„ |
| updated_at | TIMESTAMP | ì •ë³´ ìˆ˜ì • ì‹œê°„ |

### 2.2 memos í…Œì´ë¸”

ë©”ëª¨ ì €ì¥

```sql
CREATE TABLE memos (
    id TEXT PRIMARY KEY,           -- ë©”ëª¨ ID (UUID)
    user_id TEXT NOT NULL,         -- ì‚¬ìš©ì ID (FK)
    content TEXT NOT NULL,         -- ì›ë³¸ ë©”ì‹œì§€
    memo_type TEXT NOT NULL,       -- íƒ€ì…: url, text
    category TEXT NOT NULL,        -- ì¹´í…Œê³ ë¦¬
    tags TEXT,                     -- íƒœê·¸ (JSON ë°°ì—´)
    summary TEXT,                  -- AI ìš”ì•½
    url TEXT,                      -- URL (ìˆëŠ” ê²½ìš°)
    metadata TEXT,                 -- ë©”íƒ€ë°ì´í„° (JSON)
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,

    FOREIGN KEY (user_id) REFERENCES users(id)
);

-- ì¸ë±ìŠ¤
CREATE INDEX idx_memos_user_id ON memos(user_id);
CREATE INDEX idx_memos_category ON memos(category);
CREATE INDEX idx_memos_created_at ON memos(created_at);
CREATE INDEX idx_memos_user_category ON memos(user_id, category);

-- ì „ë¬¸ ê²€ìƒ‰ìš© (SQLite FTS5)
CREATE VIRTUAL TABLE memos_fts USING fts5(
    content,
    summary,
    tags,
    content=memos,
    content_rowid=rowid
);
```

| ì»¬ëŸ¼ | íƒ€ì… | ì„¤ëª… |
|------|------|------|
| id | TEXT | ë©”ëª¨ UUID |
| user_id | TEXT | ì‚¬ìš©ì FK |
| content | TEXT | ì›ë³¸ ë©”ì‹œì§€ ì „ì²´ |
| memo_type | TEXT | `url` ë˜ëŠ” `text` |
| category | TEXT | ì˜ìƒ/ë§›ì§‘/ì‡¼í•‘/í• ì¼/ì•„ì´ë””ì–´/ì½ì„ê±°ë¦¬/ê¸°íƒ€ |
| tags | TEXT | JSON ë°°ì—´ `["íƒœê·¸1", "íƒœê·¸2"]` |
| summary | TEXT | AI ìƒì„± ìš”ì•½ (30ì ì´ë‚´) |
| url | TEXT | URL (ìˆëŠ” ê²½ìš°) |
| metadata | TEXT | JSON ê°ì²´ (OG íƒœê·¸ ë“±) |
| created_at | TIMESTAMP | ì €ì¥ ì‹œê°„ |

---

## 3. ì¹´í…Œê³ ë¦¬ ì •ì˜ (11ê°œ)

| ì¹´í…Œê³ ë¦¬ | ì´ëª¨ì§€ | ì„¤ëª… | ì¸ì‹ í‚¤ì›Œë“œ/í”Œë«í¼ |
|----------|--------|------|-------------------|
| ì˜ìƒ | ğŸ“º | ìœ íŠœë¸Œ, ì˜ìƒ ì½˜í…ì¸  | youtube, í‹±í†¡, ë„·í”Œë¦­ìŠ¤, ì™“ì±  |
| ìŒì•… | ğŸµ | ìŒì•…, í”Œë ˆì´ë¦¬ìŠ¤íŠ¸ | spotify, ë©œë¡ , ì• í”Œë®¤ì§, ì‚¬ìš´ë“œí´ë¼ìš°ë“œ |
| ë§›ì§‘ | ğŸ½ï¸ | ìŒì‹ì , ì¹´í˜ | ì¹´ì¹´ì˜¤ë§µ, ë„¤ì´ë²„ì§€ë„, ë§ê³ í”Œë ˆì´íŠ¸, ë°°ë¯¼ |
| ì‡¼í•‘ | ğŸ›’ | ìƒí’ˆ, êµ¬ë§¤ ê´€ë ¨ | ì¿ íŒ¡, ë¬´ì‹ ì‚¬, ì§€ê·¸ì¬ê·¸, ë„¤ì´ë²„ì‡¼í•‘ |
| ì—¬í–‰ | âœˆï¸ | ì—¬í–‰ì§€, ìˆ™ì†Œ | ì—ì–´ë¹„ì•¤ë¹„, ì•¼ë†€ì, ì—¬ê¸°ì–´ë•Œ, booking |
| í• ì¼ | ğŸ“… | í•´ì•¼ í•  ì¼, ì¼ì • | todo, ì˜ˆì•½, ì•½ì†, ì¼ì • |
| ì•„ì´ë””ì–´ | ğŸ’¡ | ì•„ì´ë””ì–´, ìƒê° | ì•„ì´ë””ì–´, ê¸°íš, ì˜ê° |
| í•™ìŠµ | ğŸ“š | ê°•ì˜, êµìœ¡ | ì¸í”„ëŸ°, udemy, coursera, í´ë˜ìŠ¤101 |
| ê±´ê°• | ğŸ’ª | ìš´ë™, ê±´ê°•ê´€ë¦¬ | í—¬ìŠ¤, ë‹¤ì´ì–´íŠ¸, ìš”ê°€, í•„ë¼í…ŒìŠ¤ |
| ì½ì„ê±°ë¦¬ | ğŸ“° | ë¸”ë¡œê·¸, ë‰´ìŠ¤, ê¸°ì‚¬ | ë¸ŒëŸ°ì¹˜, í‹°ìŠ¤í† ë¦¬, ë¯¸ë””ì—„, ë²¨ë¡œê·¸ |
| ê¸°íƒ€ | ğŸ“Œ | ë¶„ë¥˜ ë¶ˆê°€ | ìœ„ì— í•´ë‹¹ ì•ˆ ë˜ëŠ” ê²ƒ |

---

## 4. metadata ìŠ¤í‚¤ë§ˆ

URL ë©”ëª¨ì˜ ê²½ìš° ì¶”ì¶œëœ ë©”íƒ€ë°ì´í„°:

```json
{
    "title": "í˜ì´ì§€ ì œëª©",
    "description": "OG description",
    "image": "https://example.com/thumb.jpg",
    "url": "https://example.com/page",
    "type": "youtube | instagram | naver | blog | link",
    "site_name": "YouTube",
    "extracted_at": "2024-01-15T10:30:00Z"
}
```

### í”Œë«í¼ë³„ ì¶”ê°€ ë©”íƒ€ë°ì´í„°

**YouTube**
```json
{
    "type": "youtube",
    "video_id": "abc123",
    "channel": "ì±„ë„ëª…",
    "duration": "10:30"
}
```

**Instagram**
```json
{
    "type": "instagram",
    "post_type": "reel | post | story"
}
```

---

## 5. Python ëª¨ë¸

### 5.1 Pydantic ëª¨ë¸

```python
# lib/models.py
from pydantic import BaseModel
from typing import Optional, List
from datetime import datetime
from enum import Enum

class MemoType(str, Enum):
    URL = "url"
    TEXT = "text"

class Category(str, Enum):
    VIDEO = "ì˜ìƒ"
    MUSIC = "ìŒì•…"
    FOOD = "ë§›ì§‘"
    SHOPPING = "ì‡¼í•‘"
    TRAVEL = "ì—¬í–‰"
    TODO = "í• ì¼"
    IDEA = "ì•„ì´ë””ì–´"
    LEARNING = "í•™ìŠµ"
    HEALTH = "ê±´ê°•"
    READING = "ì½ì„ê±°ë¦¬"
    ETC = "ê¸°íƒ€"

class Memo(BaseModel):
    id: str
    user_id: str
    content: str
    memo_type: MemoType
    category: Category
    tags: List[str] = []
    summary: Optional[str] = None
    url: Optional[str] = None
    metadata: Optional[dict] = None
    created_at: datetime

class User(BaseModel):
    id: str
    kakao_id: str
    access_token: Optional[str] = None
    refresh_token: Optional[str] = None
    token_expires_at: Optional[datetime] = None
    created_at: datetime
```

### 5.2 DB í•¨ìˆ˜

```python
# lib/db.py
import sqlite3
import json
import uuid
from datetime import datetime, timedelta
from typing import List, Optional

DATABASE_PATH = "data/memomate.db"

def get_connection():
    """DB ì—°ê²°"""
    conn = sqlite3.connect(DATABASE_PATH)
    conn.row_factory = sqlite3.Row
    return conn

def init_db():
    """í…Œì´ë¸” ìƒì„±"""
    conn = get_connection()
    conn.executescript("""
        CREATE TABLE IF NOT EXISTS users (
            id TEXT PRIMARY KEY,
            kakao_id TEXT UNIQUE NOT NULL,
            access_token TEXT,
            refresh_token TEXT,
            token_expires_at TIMESTAMP,
            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
            updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
        );

        CREATE TABLE IF NOT EXISTS memos (
            id TEXT PRIMARY KEY,
            user_id TEXT NOT NULL,
            content TEXT NOT NULL,
            memo_type TEXT NOT NULL,
            category TEXT NOT NULL,
            tags TEXT,
            summary TEXT,
            url TEXT,
            metadata TEXT,
            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
            FOREIGN KEY (user_id) REFERENCES users(id)
        );

        CREATE INDEX IF NOT EXISTS idx_memos_user_id ON memos(user_id);
        CREATE INDEX IF NOT EXISTS idx_memos_category ON memos(category);
        CREATE INDEX IF NOT EXISTS idx_memos_created_at ON memos(created_at);
    """)
    conn.commit()
    conn.close()

# ============ ì €ì¥ í•¨ìˆ˜ ============

async def save_memo(
    user_id: str,
    content: str,
    memo_type: str,
    category: str,
    tags: List[str],
    summary: str,
    metadata: dict = None
) -> str:
    """ë©”ëª¨ ì €ì¥"""
    conn = get_connection()
    memo_id = str(uuid.uuid4())

    # URL ì¶”ì¶œ
    url = metadata.get("url") if metadata else None

    conn.execute("""
        INSERT INTO memos (id, user_id, content, memo_type, category, tags, summary, url, metadata)
        VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
    """, (
        memo_id,
        user_id,
        content,
        memo_type,
        category,
        json.dumps(tags, ensure_ascii=False),
        summary,
        url,
        json.dumps(metadata, ensure_ascii=False) if metadata else None
    ))

    conn.commit()
    conn.close()

    return memo_id

# ============ ê²€ìƒ‰ í•¨ìˆ˜ ============

async def search_memos(
    user_id: str,
    query: str,
    category: Optional[str] = None,
    limit: int = 5
) -> List[dict]:
    """ë©”ëª¨ ê²€ìƒ‰"""
    conn = get_connection()

    sql = """
        SELECT * FROM memos
        WHERE user_id = ?
        AND (content LIKE ? OR summary LIKE ? OR tags LIKE ?)
    """
    params = [user_id, f"%{query}%", f"%{query}%", f"%{query}%"]

    if category:
        sql += " AND category = ?"
        params.append(category)

    sql += " ORDER BY created_at DESC LIMIT ?"
    params.append(limit)

    cursor = conn.execute(sql, params)
    rows = cursor.fetchall()
    conn.close()

    return [dict(row) for row in rows]

async def get_memos_by_category(
    user_id: str,
    category: str,
    limit: int = 10
) -> List[dict]:
    """ì¹´í…Œê³ ë¦¬ë³„ ë©”ëª¨ ì¡°íšŒ"""
    conn = get_connection()

    cursor = conn.execute("""
        SELECT * FROM memos
        WHERE user_id = ? AND category = ?
        ORDER BY created_at DESC
        LIMIT ?
    """, (user_id, category, limit))

    rows = cursor.fetchall()
    conn.close()

    return [dict(row) for row in rows]

async def get_memos_by_period(
    user_id: str,
    period: str
) -> List[dict]:
    """ê¸°ê°„ë³„ ë©”ëª¨ ì¡°íšŒ"""
    conn = get_connection()

    # ê¸°ê°„ ê³„ì‚°
    now = datetime.now()
    if period == "today":
        start = now.replace(hour=0, minute=0, second=0)
    elif period == "week":
        start = now - timedelta(days=7)
    elif period == "month":
        start = now - timedelta(days=30)
    else:
        start = now - timedelta(days=7)

    cursor = conn.execute("""
        SELECT * FROM memos
        WHERE user_id = ? AND created_at >= ?
        ORDER BY created_at DESC
    """, (user_id, start.isoformat()))

    rows = cursor.fetchall()
    conn.close()

    return [dict(row) for row in rows]

async def get_recent_memos(
    user_id: str,
    limit: int = 5
) -> List[dict]:
    """ìµœê·¼ ë©”ëª¨ ì¡°íšŒ"""
    conn = get_connection()

    cursor = conn.execute("""
        SELECT * FROM memos
        WHERE user_id = ?
        ORDER BY created_at DESC
        LIMIT ?
    """, (user_id, limit))

    rows = cursor.fetchall()
    conn.close()

    return [dict(row) for row in rows]

# ============ ì‚¬ìš©ì í•¨ìˆ˜ ============

async def get_or_create_user(kakao_id: str) -> dict:
    """ì‚¬ìš©ì ì¡°íšŒ ë˜ëŠ” ìƒì„±"""
    conn = get_connection()

    # ì¡°íšŒ
    cursor = conn.execute(
        "SELECT * FROM users WHERE kakao_id = ?",
        (kakao_id,)
    )
    row = cursor.fetchone()

    if row:
        conn.close()
        return dict(row)

    # ìƒì„±
    user_id = str(uuid.uuid4())
    conn.execute(
        "INSERT INTO users (id, kakao_id) VALUES (?, ?)",
        (user_id, kakao_id)
    )
    conn.commit()

    cursor = conn.execute(
        "SELECT * FROM users WHERE id = ?",
        (user_id,)
    )
    row = cursor.fetchone()
    conn.close()

    return dict(row)

async def update_user_token(
    user_id: str,
    access_token: str,
    refresh_token: str,
    expires_in: int
) -> None:
    """ì‚¬ìš©ì í† í° ì—…ë°ì´íŠ¸"""
    conn = get_connection()

    expires_at = datetime.now() + timedelta(seconds=expires_in)

    conn.execute("""
        UPDATE users
        SET access_token = ?, refresh_token = ?, token_expires_at = ?, updated_at = ?
        WHERE id = ?
    """, (access_token, refresh_token, expires_at.isoformat(), datetime.now().isoformat(), user_id))

    conn.commit()
    conn.close()
```

---

## 6. Supabase ë§ˆì´ê·¸ë ˆì´ì…˜ (í™•ì¥ ì‹œ)

MVP ì´í›„ Supabaseë¡œ ë§ˆì´ê·¸ë ˆì´ì…˜:

```sql
-- Supabase PostgreSQL

CREATE TABLE users (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    kakao_id TEXT UNIQUE NOT NULL,
    access_token TEXT,
    refresh_token TEXT,
    token_expires_at TIMESTAMPTZ,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE TABLE memos (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID REFERENCES users(id) ON DELETE CASCADE,
    content TEXT NOT NULL,
    memo_type TEXT NOT NULL CHECK (memo_type IN ('url', 'text')),
    category TEXT NOT NULL,
    tags JSONB DEFAULT '[]',
    summary TEXT,
    url TEXT,
    metadata JSONB,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- ì¸ë±ìŠ¤
CREATE INDEX idx_memos_user_id ON memos(user_id);
CREATE INDEX idx_memos_category ON memos(category);
CREATE INDEX idx_memos_created_at ON memos(created_at DESC);

-- ì „ë¬¸ ê²€ìƒ‰
CREATE INDEX idx_memos_search ON memos USING GIN (
    to_tsvector('simple', content || ' ' || COALESCE(summary, ''))
);

-- RLS ì •ì±…
ALTER TABLE memos ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can only see their own memos"
ON memos FOR SELECT
USING (user_id = auth.uid());

CREATE POLICY "Users can insert their own memos"
ON memos FOR INSERT
WITH CHECK (user_id = auth.uid());
```

---

## 7. ë‹¤ìŒ ë¬¸ì„œ

- [06_API_ì—°ë™.md](./06_API_ì—°ë™.md) - ì™¸ë¶€ API ìƒì„¸
